<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OA Companion - Daily Guidance</title>
    <!-- Load Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Google Font Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    
    <!-- Load React and ReactDOM as GLOBAL variables using standard script tags. -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <style>
        /* Apply the Inter font globally */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        /* Custom scrollbar for better mobile/desktop appearance */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }
        /* Custom colors for OA branding: Teal and Amber */
        .teal-header {
            background-color: #14B8A6; /* Teal 600 */
        }
        .teal-accent {
            color: #0D9488; /* Teal 700 */
        }
        .amber-accent {
            color: #F59E0B; /* Amber 500 */
        }
        .fuchsia-accent {
            color: #DB2777; /* Fuchsia 600 */
        }
    </style>
</head>
<body>

    <div id="root"></div>

    <script type="module">
        // --- 1. React Hook Definitions (Accessed from global React object) ---
        const { useState, useEffect, useCallback, useMemo, useRef } = React;
        
        // Firebase ES Module Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserSessionPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, addDoc, doc, deleteDoc, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- 2. Global Firebase Configuration and Utility Functions ---

        // MANDATORY GLOBAL VARIABLES from the Canvas Environment
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "PLACEHOLDER_KEY",
            projectId: "PLACEHOLDER_ID",
        };
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Utility function for exponential backoff on fetch/Firebase retries
        const retry = async (fn, retries = 10, delay = 1000) => { 
            for (let i = 0; i < retries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (i === retries - 1) throw error;
                    // Exponential backoff logic
                    await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                }
            }
        };

        // --- 3. Embedded Daily Readings (OA Focus) ---

        const dailyAbstinence = [
            "Today's Abstinence: Our common welfare should come first; personal recovery depends on OA unity and focusing on the group's primary purpose.",
            "Today's Abstinence: We do not weigh and measure our spiritual progress. We focus only on today's food plan and emotional sobriety.",
            "Today's Abstinence: We admitted that we were powerless over food and compulsive food behaviors, that our lives had become unmanageable. This admission is the bedrock of all freedom.",
            "Today's Abstinence: The desire to eat compulsively often masks a deeper emotional need. We turn to the Steps, not the refrigerator, for comfort.",
            "Today's Abstinence: We may not always be able to control what others serve, but we can control our choice of food and our response to temptation by practicing the principle of willingness.",
            "Today's Abstinence: The greatest gift of recovery is the sense of belonging we find in the fellowship, replacing isolation with connection and love.",
        ];

        const dailyFocus = [
            "Daily Focus: Humility is not thinking less of yourself, but thinking of yourself less. Seek to be helpful, not always right, especially regarding food choices.",
            "Daily Focus: Courage is required to face emotional hunger. We face our feelings with the knowledge that we are not alone; our HP is with us.",
            "Daily Focus: The promise of the program is freedom from food obsession. This freedom is maintained by continuous spiritual maintenanceâ€”Steps Ten, Eleven, and Twelve.",
            "Daily Focus: Acceptance allows us to live on life's terms, free from the tyranny of the scale or the binge. When we stop fighting reality, we can find peace in the present moment.",
            "Daily Focus: Gratitude turns what we have into enough. Start the day by listing three non-food-related things you are truly grateful for in your life today.",
            "Daily Focus: Service is the backbone of the program. What act of selfless service can I perform for another compulsive eater today?",
        ];
        
        // --- 4. Embedded Full Literature Corpus (44 VERY LONG entries - OA Focus) ---
        
        // Function to generate extremely long placeholder text
        const generateLongText = (topic) => {
            const baseSentence = `This section deeply explores the principle of ${topic}, emphasizing the profound spiritual changes necessary for sustained recovery from compulsive eating. The journey begins with deep personal honesty regarding our relationship with food. We must rigorously examine our past actions and current motivations, always seeking growth and self-improvement in abstinence. The application of this principle transforms our lives, moving us from the self-centered chaos of food addiction to a life of service, serenity, and purpose. This change requires daily diligence, constant self-inventory, and a willingness to accept life on its own terms, free from the obsession with food and body image. Recovery is not a destination, but a continuing process of spiritual unfolding. This detailed passage serves to guide the member through every facet of this crucial step/tradition, ensuring a comprehensive understanding of its vital role in maintaining a clean and fulfilling life. We repeat these principles until they become second nature, securing our spiritual foundation against the struggles of daily living. The path is clear, and the power is available through the fellowship and our Higher Power. `;
            return Array(20).fill(baseSentence).join(' '); // Repeat the base sentence 20 times for maximum length simulation
        };

        const FULL_LITERATURE_CORPUS = [
            // --- The Big Book (OA Adaptation) - 8 Chapters ---
            { book: "The Big Book (OA Adaptation)", chapter: "Chapter 1: The Doctor's Opinion", order: 1, text: generateLongText("the medical and spiritual nature of compulsive eating") },
            { book: "The Big Book (OA Adaptation)", chapter: "Chapter 2: There is a Solution", order: 2, text: generateLongText("the solution offered by the spiritual program of action") },
            { book: "The Big Book (OA Adaptation)", chapter: "Chapter 3: More About Compulsive Eating", order: 3, text: generateLongText("the obsession and allergy that defines our condition") },
            { book: "The Big Book (OA Adaptation)", chapter: "Chapter 4: We Agnostics", order: 4, text: generateLongText("finding a Higher Power that works for the individual") },
            { book: "The Big Book (OA Adaptation)", chapter: "Chapter 5: How It Works", order: 5, text: generateLongText("the foundation of acceptance, hope, and surrender to Step 3") },
            { book: "The Big Book (OA Adaptation)", chapter: "Chapter 6: Into Action (Steps 4-7)", order: 6, text: generateLongText("the process of inventory, admission, and making changes") },
            { book: "The Big Book (OA Adaptation)", chapter: "Chapter 7: Working with Others", order: 7, text: generateLongText("the vital role of sponsorship and carrying the message") },
            { book: "The Big Book (OA Adaptation)", chapter: "Chapter 8: A Vision for You", order: 8, text: generateLongText("the future of freedom and service available in recovery") },

            // --- Twelve Steps and Twelve Traditions of OA (Steps) - 12 Entries ---
            ...Array.from({ length: 12 }, (_, i) => ({
                book: "OA 12 Steps and 12 Traditions (Steps)",
                chapter: `Step ${i + 1}: ${['Powerlessness', 'Hope', 'Surrender', 'Inventory', 'Admission', 'Readiness', 'Humble Request', 'Amends List', 'Amends Made', 'Continued Inventory', 'Prayer/Meditation', 'Spiritual Awakening'][i]}`,
                order: i + 1,
                text: generateLongText(`Step ${i + 1}: The importance of the principle of ${['abstinence', 'faith', 'will', 'honesty', 'confession', 'willingness', 'humility', 'forgiveness', 'making right', 'diligence', 'conscious contact', 'carrying the message'][i]} in relation to food.`)
            })),

            // --- Twelve Steps and Twelve Traditions of OA (Traditions) - 12 Entries ---
            ...Array.from({ length: 12 }, (_, i) => ({
                book: "OA 12 Steps and 12 Traditions (Traditions)",
                chapter: `Tradition ${i + 1}: ${['Unity', 'Authority', 'Money', 'Autonomy', 'Purpose', 'Endorsements', 'Self-Support', 'Professionalism', 'Non-Affiliation', 'Opinion', 'Public Relations', 'Anonymity'][i]}`,
                order: i + 1,
                text: generateLongText(`Tradition ${i + 1}: The collective guidance on the principle of ${['common welfare', 'ultimate authority', 'finances', 'group independence', 'primary purpose', 'outside issues', 'non-profit operation', 'service without compulsion', 'no opinion on outside controversy', 'attraction not promotion', 'spiritual foundation'][i]} for the OA group.`)
            })),
            
            // --- The Twelve Concepts of OA Service - 12 Entries ---
            ...Array.from({ length: 12 }, (_, i) => ({
                book: "OA Twelve Concepts of Service",
                chapter: `Concept ${i + 1}`,
                order: i + 1,
                text: generateLongText(`Concept ${i + 1}: The practical application of the spiritual principles to the service structure of Overeaters Anonymous, ensuring the message reaches all who still suffer.`)
            })),
        ];

        // Process the embedded corpus immediately on load
        const [LITERATURE_MAP, LITERATURE_CATEGORIES] = (() => {
            const allChunks = FULL_LITERATURE_CORPUS;
            
            const categorizedMap = allChunks.reduce((acc, chunk) => {
                const key = `${chunk.book}: ${chunk.chapter}`;
                if (!acc[key]) {
                    acc[key] = [];
                }
                acc[key].push(chunk);
                return acc;
            }, {});

            for (const key in categorizedMap) {
                categorizedMap[key].sort((a, b) => a.order - b.order);
            }

            const bookGroups = {};
            for (const key in categorizedMap) {
                const [book, chapter] = key.split(': ');
                if (!bookGroups[book]) {
                    bookGroups[book] = [];
                }
                bookGroups[book].push({ chapterKey: key, chapterTitle: chapter, order: categorizedMap[key][0]?.order || 999 });
            }
            
            const bookOrder = [
                "The Big Book (OA Adaptation)", 
                "OA 12 Steps and 12 Traditions (Steps)", 
                "OA 12 Steps and 12 Traditions (Traditions)", 
                "OA Twelve Concepts of Service"
            ];

            const categories = [];
            bookOrder.forEach(bookTitle => {
                if (bookGroups[bookTitle]) {
                    bookGroups[bookTitle].sort((a, b) => a.order - b.order);
                    categories.push({ 
                        label: `--- ${bookTitle} ---`, 
                        keys: bookGroups[bookTitle].map(item => item.chapterKey) 
                    });
                }
            });

            return [categorizedMap, categories];
        })();


        // --- 5. Custom Hooks ---

        // Custom Hook for Web Speech API (TTS) - CHUNKING IMPLEMENTATION (The Fix)
        const useWebSpeech = () => {
            const [isSpeaking, setIsSpeaking] = useState(false);
            const [preferredVoice, setPreferredVoice] = useState(null);
            const speechRef = useRef(null); 

            // 1. Load voices once and on change
            useEffect(() => {
                if (!window.speechSynthesis) return;

                const loadVoices = () => {
                    const voices = window.speechSynthesis.getVoices();
                    // Try to find a clear English voice (Google voices are often higher quality)
                    const voice = voices.find(v => v.lang.startsWith('en') && (v.name.includes('Google') || v.default));
                    setPreferredVoice(voice || null);
                };

                loadVoices();

                window.speechSynthesis.onvoiceschanged = loadVoices;

                return () => {
                    window.speechSynthesis.onvoiceschanged = null;
                };
            }, []);

            const stopSpeaking = useCallback(() => {
                if (window.speechSynthesis && window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                    setIsSpeaking(false);
                }
            }, []);

            const speakText = useCallback((text) => {
                if (!window.speechSynthesis) {
                    console.error("Browser does not support Web Speech Synthesis API.");
                    return;
                }
                
                // Always cancel previous speech
                stopSpeaking(); 

                if (!text) return;

                // --- TEXT CHUNKING LOGIC FOR MOBILE RELIABILITY ---
                const maxChunkLength = 200; // Small chunks for maximum mobile reliability
                const chunks = [];
                
                // Split text by common separators (period, newline, question mark, exclamation mark)
                const sentences = text.split(/([.?!,:]\s*|\n)/g).filter(s => s.trim().length > 0);
                let currentChunk = '';
                
                for (const sentence of sentences) {
                    if ((currentChunk + sentence).length > maxChunkLength && currentChunk.length > 0) {
                        chunks.push(currentChunk.trim());
                        currentChunk = sentence;
                    } else {
                        currentChunk += sentence;
                    }
                }
                if (currentChunk.length > 0) {
                    chunks.push(currentChunk.trim());
                }
                
                let chunkIndex = 0;

                const speakNextChunk = () => {
                    if (chunkIndex >= chunks.length) {
                        setIsSpeaking(false);
                        return;
                    }

                    const utterance = new SpeechSynthesisUtterance(chunks[chunkIndex]);
                    
                    if (preferredVoice) {
                        utterance.voice = preferredVoice;
                    }
                    
                    utterance.rate = 1.0; 
                    utterance.pitch = 1.0; 
                    
                    // Recursive call to speak the next chunk on end
                    utterance.onend = () => {
                        chunkIndex++;
                        speakNextChunk();
                    };
                    
                    utterance.onerror = (event) => {
                        console.error('Speech Synthesis Error on chunk:', event);
                        setIsSpeaking(false);
                    };

                    window.speechSynthesis.speak(utterance);
                    
                    // Only set speaking state once on the first chunk
                    if (chunkIndex === 0) {
                        setIsSpeaking(true);
                    }
                };

                speakNextChunk();
                // --- END TEXT CHUNKING LOGIC ---

            }, [stopSpeaking, preferredVoice]);
            
            useEffect(() => {
                return () => {
                    stopSpeaking();
                };
            }, [stopSpeaking]);

            return { speakText, isSpeaking, stopSpeaking };
        };

        // Custom Hook for Firebase Initialization and Authentication
        const useFirebase = () => {
            const [db, setDb] = useState(null);
            const [userId, setUserId] = useState(null);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [isDbConfigured, setIsDbConfigured] = useState(false);
            
            const isConfigValid = useMemo(() => {
                return typeof firebaseConfig.projectId === 'string' && firebaseConfig.projectId !== 'PLACEHOLDER_ID';
            }, [firebaseConfig]);


            useEffect(() => {
                
                if (!isConfigValid) {
                    console.warn("Firebase config is missing or using placeholder. Log functionality is disabled.");
                    setUserId(crypto.randomUUID()); // Ensure we have a dummy ID for anonymous UI display
                    setIsAuthReady(true);
                    setIsDbConfigured(false);
                    return;
                }
                
                setLogLevel('debug');

                const setupFirebase = async () => {
                    try {
                        const app = initializeApp(firebaseConfig);
                        const firestore = getFirestore(app);
                        const firebaseAuth = getAuth(app);
                        
                        // DB Connection established, set configured to true
                        setIsDbConfigured(true); 
                        setDb(firestore);
                        
                        await setPersistence(firebaseAuth, browserSessionPersistence);

                        const unsubscribe = onAuthStateChanged(firebaseAuth, async (user) => {
                            if (user) {
                                setUserId(user.uid);
                            } else {
                                try {
                                    if (initialAuthToken) {
                                        await retry(() => signInWithCustomToken(firebaseAuth, initialAuthToken));
                                    } else {
                                        await retry(() => signInAnonymously(firebaseAuth));
                                    }
                                    setUserId(firebaseAuth.currentUser.uid);
                                } catch (error) {
                                    console.error("Firebase Auth failed, using random ID for non-persistent access:", error);
                                    setUserId(crypto.randomUUID()); 
                                    // Do NOT set isDbConfigured to false here, as the DB object is valid.
                                }
                            }
                            setIsAuthReady(true);
                        });

                        return () => unsubscribe();
                    } catch (e) {
                        console.error("Error initializing Firebase services:", e);
                        setUserId(crypto.randomUUID()); 
                        setIsAuthReady(true);
                        setIsDbConfigured(false); // Only set false if init fails
                    }
                };

                setupFirebase();
            }, [isConfigValid, initialAuthToken]); 

            return { db, userId, isAuthReady, isDbConfigured };
        };

        // Component to display messages/alerts instead of using alert()
        const Alert = ({ message, type, onClose }) => {
            if (!message) return null;

            const baseStyle = "p-3 text-sm rounded-lg fixed top-2 left-1/2 -translate-x-1/2 z-50 shadow-xl max-w-sm w-11/12 transition-all duration-300 transform";
            let colorStyle = "";

            switch (type) {
                case 'success':
                    colorStyle = "bg-green-100 text-green-800 border border-green-200";
                    break;
                case 'error':
                    colorStyle = "bg-red-100 text-red-800 border border-red-200";
                    break;
                default:
                    colorStyle = "bg-blue-100 text-blue-800 border border-blue-200";
            }

            useEffect(() => {
                const timer = setTimeout(() => {
                    onClose();
                }, 4000); 

                return () => clearTimeout(timer);
            }, [message, onClose]);

            return React.createElement(
                'div',
                { className: `${baseStyle} ${colorStyle}`, role: 'alert' },
                React.createElement(
                    'span',
                    { className: 'font-medium' },
                    type.toUpperCase(),
                    ': '
                ),
                ' ',
                message
            );
        };

        // --- 6. React Components (TTS Integrated) ---

        const ListenButton = ({ text, isSpeaking, stopSpeaking, speakText }) => {
            const handleToggle = () => {
                if (isSpeaking) {
                    stopSpeaking();
                } else {
                    speakText(text);
                }
            };

            return React.createElement(
                'button',
                {
                    onClick: handleToggle,
                    className: `ml-auto flex items-center px-3 py-1 text-xs font-semibold rounded-full transition duration-150 ${
                        isSpeaking
                            ? 'bg-red-500 hover:bg-red-600 text-white shadow-md'
                            : 'bg-teal-200 hover:bg-teal-300 text-teal-800'
                    }`
                },
                React.createElement('svg', { 
                    className: `w-4 h-4 mr-1 ${isSpeaking ? 'animate-pulse' : ''}`, 
                    fill: 'none', 
                    stroke: 'currentColor', 
                    viewBox: '0 0 24 24' 
                },
                    isSpeaking 
                        ? React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: '2', d: 'M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z' }) // Stop icon
                        : React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: '2', d: 'M15.536 8.464l-4.536 4.536L8.464 15.536a2 2 0 01-2.828-2.828l4.536-4.536L15.536 8.464z' }) // Listen icon (play/speaker)
                ),
                isSpeaking ? 'Stop' : 'Listen'
            );
        };


        // Component for Daily Readings (OA Focus)
        const DailyReadings = ({ speakText, stopSpeaking, isSpeaking }) => {
            const getDailyText = useCallback((dataArray) => {
                const now = new Date();
                const start = new Date(now.getFullYear(), 0, 0);
                const diff = now - start;
                const dayOfYear = Math.floor(diff / (1000 * 60 * 60 * 24));
                const index = dayOfYear % dataArray.length;
                return dataArray[index];
            }, []);

            const reflection = useMemo(() => getDailyText(dailyAbstinence), [getDailyText]);
            const meditation = useMemo(() => getDailyText(dailyFocus), [getDailyText]);
            
            const reflectionText = reflection.replace("Today's Abstinence: ", 'Daily Abstinence: ');
            const meditationText = meditation.replace("Daily Focus: ", 'Daily Focus: ');

            return React.createElement(
                'div',
                { className: 'space-y-6' },
                React.createElement(
                    'h2',
                    { className: 'text-2xl font-extrabold teal-accent text-center border-b pb-3' },
                    'Daily Guidance for Abstinence'
                ),
                React.createElement(
                    'div',
                    { className: 'bg-green-50 border-l-4 border-green-500 rounded-xl p-5 shadow-xl transition hover:shadow-2xl space-y-3' },
                    React.createElement(
                        'div',
                        { className: 'flex items-center justify-between' },
                        React.createElement(
                            'p',
                            { className: 'font-bold text-green-700 text-xl flex items-center' },
                            React.createElement('svg', { className: 'w-6 h-6 mr-2', fill: 'none', stroke: 'currentColor', viewBox: '0 0 24 24' },
                                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: '2', d: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z' })
                            ),
                            "Today's Abstinence"
                        ),
                        React.createElement(ListenButton, { 
                            text: reflectionText, 
                            isSpeaking: isSpeaking, 
                            stopSpeaking: stopSpeaking, 
                            speakText: speakText 
                        })
                    ),
                    React.createElement(
                        'p',
                        { className: 'text-gray-700 italic leading-relaxed' },
                        reflection.replace("Today's Abstinence: ", '')
                    )
                ),
                React.createElement(
                    'div',
                    { className: 'bg-amber-50 border-l-4 border-amber-500 rounded-xl p-5 shadow-xl transition hover:shadow-2xl space-y-3' },
                    React.createElement(
                        'div',
                        { className: 'flex items-center justify-between' },
                        React.createElement(
                            'p',
                            { className: 'font-bold text-amber-700 text-xl flex items-center' },
                            React.createElement('svg', { className: 'w-6 h-6 mr-2', fill: 'none', stroke: 'currentColor', viewBox: '0 0 24 24' },
                                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: '2', d: 'M16 4v12l-4-2-4 2V4M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z' })
                            ),
                            'Daily Focus'
                        ),
                        React.createElement(ListenButton, { 
                            text: meditationText, 
                            isSpeaking: isSpeaking, 
                            stopSpeaking: stopSpeaking, 
                            speakText: speakText 
                        })
                    ),
                    React.createElement(
                        'p',
                        { className: 'text-gray-700 italic leading-relaxed' },
                        meditation.replace("Daily Focus: ", '')
                    )
                )
            );
        };

        // Component for Navigating the Full Literature (OA Focus)
        const LiteratureSelector = ({ literatureMap, literatureCategories, speakText, stopSpeaking, isSpeaking }) => { 
            const [selectedKey, setSelectedKey] = useState(null);
            
            // Set initial key once literature is ready
            useEffect(() => {
                if (!selectedKey && literatureCategories.length > 0) { 
                    const firstKey = literatureCategories.find(section => section.keys.length > 0)?.keys[0]; 
                    if (firstKey) {
                         setSelectedKey(firstKey);
                    }
                }
            }, [literatureCategories, selectedKey]); 

            // Since the literature is now embedded, we always have it.
            if (literatureCategories.length === 0) {
                 return React.createElement(
                    'div', 
                    { className: 'text-center p-8 text-gray-500' }, 
                    'Error: Embedded literature data is unavailable.'
                );
            }

            const currentChunks = literatureMap?.[selectedKey] || [];
            const currentContent = currentChunks.map(c => c.text).join('\n\n');
            const contentToSpeak = `${selectedKey}. ${currentContent}`;
            

            return React.createElement(
                'div',
                { className: 'space-y-4 pt-4 border-t border-gray-200' },
                React.createElement('h3', { className: 'text-xl font-bold text-gray-700' }, 'Full Chapter Selector'),
                
                React.createElement(
                    'select',
                    {
                        onChange: (e) => {
                            setSelectedKey(e.target.value);
                            stopSpeaking(); // Stop speech immediately on selection change
                        },
                        value: selectedKey || '',
                        className: 'w-full p-3 border border-gray-300 rounded-lg bg-white shadow-sm focus:border-teal-500 text-gray-700'
                    },
                    literatureCategories.map((section, index) => ( 
                        React.createElement(
                            React.Fragment,
                            { key: index },
                            React.createElement(
                                'option',
                                { value: "", disabled: true, className: 'font-bold bg-gray-100' },
                                section.label
                            ),
                            section.keys.map(key => (
                                React.createElement(
                                    'option',
                                    { key: key, value: key, className: 'text-gray-800' },
                                    key
                                )
                            ))
                        )
                    ))
                ),
                
                React.createElement(
                    'div',
                    { className: 'p-4 bg-gray-50 rounded-xl border border-gray-200 max-h-96 overflow-y-auto custom-scrollbar' },
                    React.createElement(
                        'div',
                        { className: 'flex justify-between items-center mb-2' },
                        React.createElement('h4', { className: 'font-bold text-lg text-teal-700' }, selectedKey || 'Select a Chapter'),
                        React.createElement(ListenButton, { 
                            text: contentToSpeak, 
                            isSpeaking: isSpeaking, 
                            stopSpeaking: stopSpeaking, 
                            speakText: speakText 
                        })
                    ),
                    React.createElement('p', { className: 'text-gray-800 whitespace-pre-wrap mt-1 text-sm' }, currentContent || 'Select a chapter above to view its content.')
                )
            );
        };

        // Component for Offline Literature Search (OA Focus)
        const LiteratureSearch = ({ literatureMap, literatureCategories, speakText, stopSpeaking, isSpeaking }) => { 
            const [query, setQuery] = useState('');
            const [result, setResult] = useState({ title: 'Welcome', content: 'Enter a word or principle (e.g., "abstinence," "food plan," or "Step 12") to search the embedded literature.' });
            
            const resultToSpeak = `${result.title}. ${result.content}`;
            
            // Flattens the map into a single array for searching
            const searchableCorpus = useMemo(() => {
                if (!literatureMap) return [];
                const corpus = [];
                for (const chapterKey in literatureMap) {
                    literatureMap[chapterKey].forEach(chunk => {
                        corpus.push({
                            title: chapterKey,
                            text: chunk.text,
                            order: chunk.order
                        });
                    });
                }
                return corpus;
            }, [literatureMap]);

            const findGuidance = useCallback((searchQuery) => {
                const lowerQuery = searchQuery.toLowerCase().trim();

                if (!lowerQuery || lowerQuery.length < 3) {
                     return { title: "Search Query Too Short", content: "Please enter a word or phrase with at least 3 letters to search the embedded literature." };
                }
                
                let bestTitleMatch = null;
                let bestContentMatch = null;
                let highestCount = 0;

                for (const item of searchableCorpus) {
                    const lowerTitle = item.title.toLowerCase();
                    const lowerContent = item.text.toLowerCase();
                    
                    const isTitleMatch = lowerTitle.includes(lowerQuery);
                    const count = (lowerContent.match(new RegExp(lowerQuery, 'g')) || []).length;
                    
                    // 1. Prioritize an exact or clear title match
                    if (isTitleMatch) {
                        bestTitleMatch = {
                            title: `Match in Title: ${item.title}`, 
                            content: `The term "${searchQuery}" matched the chapter title. Reading the full chapter content below.` 
                        };
                    }
                    
                    // 2. Track the best content match by count
                    if (count > highestCount) {
                        highestCount = count;
                        
                        // Extract a snippet for context
                        const matchIndex = lowerContent.indexOf(lowerQuery);
                        const contextWindow = 200; // Context window size
                        const startIndex = Math.max(0, matchIndex - contextWindow); 
                        const endIndex = Math.min(item.text.length, matchIndex + lowerQuery.length + contextWindow);
                        
                        let snippet = item.text.substring(startIndex, endIndex).trim();
                        
                        if (startIndex > 0) snippet = '... ' + snippet;
                        if (endIndex < item.text.length) snippet = snippet + ' ...';

                        bestContentMatch = { 
                            title: `Excerpt from: ${item.title} (Matches: ${count})`, 
                            content: `"${snippet}"\n\n(Found using the term: "${searchQuery}")` 
                        };
                    }
                }
                
                // Final Decision: 
                if (bestContentMatch) {
                    return bestContentMatch;
                } else if (bestTitleMatch) {
                    return bestTitleMatch;
                }

                return { 
                    title: "No Excerpt Found", 
                    content: `The search term "${searchQuery}" did not appear in the loaded literature excerpts. Try searching for a core OA principle.`
                };
            }, [searchableCorpus]);

            const handleSearch = () => {
                if (query) {
                    const searchResult = findGuidance(query);
                    setResult(searchResult);
                    stopSpeaking();
                }
            };
            
            const handleKeyPress = (e) => {
                if (e.key === 'Enter') {
                    handleSearch();
                }
            };
            
            return React.createElement(
                'div',
                { className: 'space-y-4' },
                React.createElement('h2', { className: 'text-2xl font-extrabold amber-accent text-center border-b pb-3' }, 'Literature Search'),
                React.createElement('p', { className: 'text-sm text-gray-500 text-center' }, 'Searching Big Book, 12x12, and Concepts (Full Simulated Content).'),

                React.createElement(
                    'div',
                    { className: 'flex gap-3' },
                    React.createElement('input', {
                        type: 'text',
                        placeholder: "Search principles (e.g., 'food plan' or 'Step 10')",
                        value: query,
                        onChange: (e) => setQuery(e.target.value),
                        onKeyPress: handleKeyPress,
                        className: 'flex-grow p-3 border border-gray-300 rounded-lg focus:border-amber-500 shadow-sm'
                    }),
                    React.createElement(
                        'button',
                        {
                            onClick: handleSearch,
                            className: 'bg-amber-600 hover:bg-amber-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200'
                        },
                        React.createElement('svg', { className: 'w-5 h-5 inline-block', fill: 'none', stroke: 'currentColor', viewBox: '0 0 24 24' },
                            React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: '2', d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                        )
                    )
                ),
                
                React.createElement(
                    'div',
                    { className: 'p-4 bg-amber-50 rounded-xl border border-amber-200 min-h-[100px] overflow-y-auto max-h-64 shadow-inner space-y-2' },
                    React.createElement(
                        'div',
                        { className: 'flex justify-between items-center' },
                        React.createElement('h4', { className: 'font-bold text-lg mb-1 text-amber-700' }, result.title),
                        React.createElement(ListenButton, { 
                            text: resultToSpeak, 
                            isSpeaking: isSpeaking, 
                            stopSpeaking: stopSpeaking, 
                            speakText: speakText 
                        })
                    ),
                    React.createElement('p', { className: 'text-gray-800 whitespace-pre-wrap mt-1 text-sm' }, result.content)
                ),

                React.createElement(LiteratureSelector, { 
                    literatureMap, 
                    literatureCategories, 
                    speakText, 
                    stopSpeaking, 
                    isSpeaking
                })
            );
        };

        // Component for Check-in Log (Firestore Integration - OA Focus)
        const CheckinLog = ({ db, userId, isAuthReady, showAlert, isDbConfigured }) => {
            const [logEntries, setLogEntries] = useState([]);
            const [newEntryText, setNewEntryText] = useState('');
            
            // Log collection uses private, user-specific path
            const logCollectionPath = `artifacts/${appId}/users/${userId}/oa_checkin_log`;

            useEffect(() => {
                // Only run if authentication is ready, db object exists, and userId is determined
                if (!isAuthReady || !db || !userId || !isDbConfigured) return;
                
                const logRef = collection(db, logCollectionPath);
                
                const unsubscribe = onSnapshot(logRef, (snapshot) => {
                    const entries = [];
                    snapshot.forEach(doc => {
                        entries.push({ id: doc.id, ...doc.data() });
                    });
                    
                    entries.sort((a, b) => (b.timestamp?.seconds || 0) - (a.timestamp?.seconds || 0));
                    setLogEntries(entries);
                }, (error) => {
                    console.error("Error setting up log listener:", error);
                    showAlert("Failed to load log history. Check database connection/rules.", 'error');
                });

                return () => unsubscribe();
            }, [db, userId, isAuthReady, logCollectionPath, showAlert, isDbConfigured]);


            const handleSaveEntry = async () => {
                const text = newEntryText.trim();
                if (!text || !db || !userId) {
                    showAlert("Please write a message before saving. Log disabled if DB is not configured.", 'info');
                    return;
                }
                
                if (!isDbConfigured) {
                     showAlert("Log Functionality Disabled. Database is not available.", 'error');
                    return;
                }

                const newLogEntry = {
                    text: text,
                    timestamp: new Date(), 
                    userId: userId,
                };

                try {
                    await retry(() => addDoc(collection(db, logCollectionPath), newLogEntry));
                    setNewEntryText('');
                    showAlert("Check-in saved successfully!", 'success');
                } catch (error) {
                    console.error("Error saving check-in:", error);
                    showAlert(`Failed to save check-in. Error: ${error.message}. Check network/Firestore setup.`, 'error');
                }
            };

            const handleDeleteEntry = async (id) => {
                if (!db || !isDbConfigured) return;
                
                // Using window.confirm() here as a controlled exception for in-iframe deletion prompt
                if (!window.confirm("Are you sure you want to delete this log entry?")) {
                    return;
                }
                
                try {
                    await retry(() => deleteDoc(doc(db, logCollectionPath, id)));
                    showAlert("Entry deleted.", 'success');
                } catch (error) {
                    console.error("Error deleting entry:", error);
                    showAlert(`Failed to delete entry. Error: ${error.message}`, 'error');
                }
            };
            
            if (!isAuthReady) {
                return React.createElement('div', { className: "text-center p-8 text-gray-500" }, "Initializing database connection...");
            }
            
            if (!isDbConfigured) {
                 return React.createElement('div', { className: "text-center p-8 text-red-500 font-medium bg-red-100 rounded-xl" }, 
                    "Log Functionality Disabled. Database is not available or failed to connect."
                );
            }

            return React.createElement(
                'div',
                { className: 'space-y-4' },
                React.createElement('h2', { className: 'text-2xl font-extrabold fuchsia-accent text-center border-b pb-3' }, 'Sponsor/Food Check-in Log (Saved)'),
                
                React.createElement(
                    'div',
                    { className: 'bg-white p-4 rounded-xl shadow-lg border border-fuchsia-200' },
                    React.createElement('textarea', {
                        rows: '3',
                        placeholder: "Log your food plan, emotional state, or struggles with compulsive eating for your sponsor...",
                        value: newEntryText,
                        onChange: (e) => setNewEntryText(e.target.value),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:border-fuchsia-500 transition duration-150 ease-in-out'
                    }),
                    React.createElement(
                        'button',
                        {
                            onClick: handleSaveEntry,
                            disabled: !db,
                            className: 'mt-3 w-full bg-fuchsia-600 hover:bg-fuchsia-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-200 disabled:opacity-50'
                        },
                        "Save Today's Check-in"
                    )
                ),

                React.createElement(
                    'div',
                    { className: 'bg-white p-4 rounded-xl shadow-lg max-h-80 overflow-y-auto custom-scrollbar border border-gray-200' },
                    React.createElement('h3', { className: 'text-xl font-semibold text-gray-700 mb-4 border-b pb-2' }, `History (${logEntries.length} Entries)`),
                    
                    logEntries.length === 0 ? (
                        React.createElement('p', { className: 'text-gray-500 italic' }, 'No entries saved yet. Your saved log will appear here.')
                    ) : (
                        React.createElement(
                            'ul',
                            { className: 'space-y-4' },
                            logEntries.map(entry => (
                                React.createElement(
                                    'li',
                                    { key: entry.id, className: 'border-b border-gray-100 pb-3 last:border-b-0' },
                                    React.createElement(
                                        'div',
                                        { className: 'flex justify-between items-start' },
                                        React.createElement(
                                            'p',
                                            { className: 'text-sm text-gray-500 font-medium' },
                                            entry.timestamp && new Date(entry.timestamp.seconds * 1000).toLocaleDateString(),
                                            ' - ',
                                            entry.timestamp && new Date(entry.timestamp.seconds * 1000).toLocaleTimeString()
                                        ),
                                        React.createElement(
                                            'button',
                                            {
                                                onClick: () => handleDeleteEntry(entry.id),
                                                className: 'text-gray-400 hover:text-fuchsia-500 transition p-1',
                                                title: 'Delete Entry'
                                            },
                                            React.createElement('svg', { xmlns: 'http://www.w3.org/2000/svg', className: 'h-5 w-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                                                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: '2', d: 'M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16' })
                                            )
                                        )
                                    ),
                                    React.createElement('p', { className: 'text-gray-800 whitespace-pre-wrap mt-1 text-sm' }, entry.text)
                                )
                            ))
                        )
                    )
                )
            );
        };


        // Main App Content Container
        const AppContent = ({ db, userId, isAuthReady, showAlert, isDbConfigured, speakText, stopSpeaking, isSpeaking }) => { 
            const [activeTab, setActiveTab] = useState('daily');
            
            const tabs = [
                { id: 'daily', name: 'Guidance', icon: (color) => React.createElement('svg', { className: `w-6 h-6 ${color}`, fill: 'none', stroke: 'currentColor', viewBox: '0 0 24 24' }, React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: '2', d: 'M8 7v10l9 3 9-3V7l-9-3-9 3z' })) },
                { id: 'search', name: 'Reference', icon: (color) => React.createElement('svg', { className: `w-6 h-6 ${color}`, fill: 'none', stroke: 'currentColor', viewBox: '0 0 24 24' }, React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: '2', d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })) },
                { id: 'log', name: 'Check-in', icon: (color) => React.createElement('svg', { className: `w-6 h-6 ${color}`, fill: 'none', stroke: 'currentColor', viewBox: '0 0 24 24' }, React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: '2', d: 'M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z' })) },
            ];

            const renderContent = () => {
                switch (activeTab) {
                    case 'daily':
                        return React.createElement(DailyReadings, { speakText, stopSpeaking, isSpeaking });
                    case 'search':
                        return React.createElement(LiteratureSearch, {
                            literatureMap: LITERATURE_MAP,
                            literatureCategories: LITERATURE_CATEGORIES, 
                            speakText,
                            stopSpeaking,
                            isSpeaking
                        });
                    case 'log':
                        return React.createElement(CheckinLog, { db: db, userId: userId, isAuthReady: isAuthReady, showAlert: showAlert, isDbConfigured: isDbConfigured });
                    default:
                        return React.createElement(DailyReadings, { speakText, stopSpeaking, isSpeaking });
                }
            };
            
            useEffect(() => {
                stopSpeaking();
            }, [activeTab, stopSpeaking]);


            return React.createElement(
                'div',
                { className: 'flex flex-col h-full bg-gray-50' },
                
                React.createElement(
                    'header',
                    { className: 'bg-white border-b border-gray-200 shadow-lg' },
                    React.createElement(
                        'div',
                        { className: 'flex justify-around items-center p-1 sm:p-2' },
                        tabs.map(tab => (
                            React.createElement(
                                'button',
                                {
                                    key: tab.id,
                                    onClick: () => setActiveTab(tab.id),
                                    className: `flex flex-col items-center py-2 px-3 text-sm font-semibold transition-all duration-200 rounded-lg ${
                                        activeTab === tab.id
                                            ? 'text-teal-700 bg-teal-100/50'
                                            : 'text-gray-500 hover:text-teal-600 hover:bg-gray-50'
                                    }`
                                },
                                tab.icon(activeTab === tab.id ? 'text-teal-600' : 'text-gray-400'),
                                React.createElement('span', { className: 'mt-1 text-xs' }, tab.name)
                            )
                        ))
                    )
                ),

                React.createElement(
                    'main',
                    { className: 'flex-grow overflow-y-auto p-4 custom-scrollbar' },
                    renderContent()
                ),
                
                React.createElement(
                    'footer',
                    { className: 'bg-teal-700 text-white p-2 text-center text-xs font-light' },
                    'OA Companion | Recovery is a journey. Keep coming back.'
                )
            );
        };


        function App() {
            const { db, userId, isAuthReady, isDbConfigured } = useFirebase();
            const { speakText, isSpeaking, stopSpeaking } = useWebSpeech();
            const [alertMessage, setAlertMessage] = useState(null);
            const [alertType, setAlertType] = useState('info');

            const showAlert = useCallback((message, type = 'info') => {
                setAlertMessage(message);
                setAlertType(type);
            }, []);
            
            const handleAlertClose = useCallback(() => {
                setAlertMessage(null);
            }, []);
            
            const displayUserId = isDbConfigured && userId
                ? userId 
                : 'Offline/Anonymous';


            return React.createElement(
                'div',
                { className: 'min-h-screen bg-gray-100 flex justify-center p-0 sm:p-4' },
                React.createElement(Alert, { message: alertMessage, type: alertType, onClose: handleAlertClose }),
                
                React.createElement(
                    'div',
                    { className: 'w-full max-w-lg border-4 border-gray-900 bg-white rounded-t-3xl sm:rounded-3xl shadow-2xl overflow-hidden flex flex-col min-h-screen sm:h-[90vh] sm:min-h-[700px]' },
                    
                    React.createElement(
                        'div',
                        { className: 'teal-header text-white p-4 flex justify-between items-center shadow-xl' },
                        React.createElement(
                            'h1',
                            { className: 'text-2xl font-extrabold flex items-center' },
                            React.createElement('svg', { className: 'w-7 h-7 mr-2', fill: 'none', stroke: 'currentColor', viewBox: '0 0 24 24' },
                                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: '2', d: 'M12 8c1.657 0 3 .895 3 2s-1.343 2-3 2-3-.895-3-2 1.343-2 3-2zM21 12c0 1.657-4.03 3-9 3s-9-1.343-9-3c0-1.657 4.03-3 9-3s9 1.343 9 3zM3 17.25c0 .546 3.037 1.25 9 1.25s9-.704 9-1.25M3 21.75c0 .546 3.037 1.25 9 1.25s9-.704 9-1.25' }) // Fork and spoon for food theme
                            ),
                            'OA Companion'
                        ),
                        React.createElement(
                            'span',
                            { className: 'text-xs text-teal-300 italic' },
                            'User ID: ',
                            displayUserId
                        )
                    ),

                    React.createElement(AppContent, { 
                        db: db, 
                        userId: userId, 
                        isAuthReady: isAuthReady, 
                        showAlert: showAlert,
                        isDbConfigured: isDbConfigured,
                        speakText: speakText,
                        stopSpeaking: stopSpeaking,
                        isSpeaking: isSpeaking
                    })
                )
            );
        }

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(React.createElement(App));
    </script>
</body>
</html>
